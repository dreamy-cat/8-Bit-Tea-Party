;8-Бит Чаепитие! 2021.
;Лицензия: Creative Commons.
;Платформа: 8086, VGA(256Kb).
;Инструменты: NASM.
;Модули: VGA-X,...
;Авторы: Данила Перов(peroff@protonmail.com).
;Быстродействие: примерное количество тактов для каждой процедуры.
;Память: процед_1 = N, процед_2 занимает М байт.
;Краткая история изменений:
;ДД.ММ.ГГ, И.И.: Короткое сообщение что добавлено, удалено или исправлено.

%include "VGA-X.ASM"            ;Директива включения заголовка для NASM.


;!Минимальный комплект, при условии если всё ок, то до 14 ноября.
;Печать строки пока без окна, используя наш формат и с параметром смещения и
;количеством символов для печати. Остальное уже будем шлифовать после.


; Процедуры печати в экранную память режима Х, нашего 16-ти битного формата
;строк. Смотри файл string.asm для подробного описания формата.
; Использует дополнительно пару глобальных параметров: шрифт по умолчанию и
;текущие позиции вывода для удобства вызовов. Для старта можно взять пока
;системный шрифт ВГА адаптера. Его можно получить при вызове функции.
;Шрифт минимально черно-белый размеры были по умолчанию 8*8.


; Глобальные переменные и константы, когда будет доделано, то скинем их в
;общий файл библиотеки режима Х.


;Биты, задающие масштаб, в параметрах функций VXPrintChar и VXPrintString
CHAR_SCALE_MASK         EQU 00001111b

;! или CHAR или SYMBOL тут вопрос в языке, но уже взяли CHAR, так что далее
;используем его. :)


vx_cursor_x     dw 0000h        ;Левая точка позиции курсора, 0..319.
vx_cursor_y     dw 0000h        ;Верхняя точка позиции курсора, 0..239.
vx_font_addr    dd 00000000h    ;Полный адрес шрифта, смещение и сегмент.
vx_font_first_c db 00h          ;Код первого символа в шрифте.
vx_font_chars   db 00h          ;Количество символов в шрифте, 0 = 256.
vx_font_char_b  db 00h          ;Количество байт на один символ.
vx_font_width   db 00h          ;Ширина символа в точках.
vx_font_height  db 00h          ;Высота символа в линиях.

vx_font_color   db 00h          ;! глобальный цвет для печати по-умолчанию.
vx_font_bkg     db 00h          ;! глобальный цвет фона, пока резерв.


;Если потребуются вспомогательные процедуры работы со шрифтом, то добавляй
;временно прямо сюда, если что подумаем позже об отдельном файле. VXFontLoad.

;Загружаем в глобальные переменные адрес и прочие данные системного шрифта
;по умолчанию, размер: 8x8.
;Вход:  нет;
;Выход: измененные глобальные переменные vx_font_*

;! Вот эту процедуру пока оставим как есть, если что потом вынесем или в
;библотеку базового ввода-вывода или дополним и будет более универсальная.
;Стараемся кстати, названия процедур условно укладывать в 16 символов.

VXLoadFontBIOS:
        pushf
        push ax
        push bx
        push cx
        push dx
        push bp
        push es

        mov ax,1130h                    ; получить параметры шрифта из BIOS
        mov bh,3                        ; выбираем шрифт 8x8
        int 10h
        mov ax,es
        mov [vx_font_addr],ax           ; сегмент данных шрифта
        mov [vx_font_addr + 2],bp       ; смещение данных шрифта
        mov byte [vx_font_chars],0      ; количество символов в шрифте, 0=256
        mov byte [vx_font_char_b],8     ; байтов на один символ
        mov byte [vx_font_width],8      ; ширина символа
        mov byte [vx_font_height],8     ; высота символа

        pop es
        pop bp
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret

;! Вот эту процедуру пока оставляем на потом, здесь потребуется фантазия и
;пока не ясно что именно нам нужно будет по функционалу для вывода в окно.

;Дополнительно, только если уже ниже процедуры реализованы.
;Всё по аналогии, только с учетом вывода в окно.
;Параметры пока подумаем, но главное, что бы вывод шел с ограничением
;относительно логического окна, а не экрана и плюс с разными дополнительными
;возможностями.

VXPrintStrWin:
        pushf
        popf
        ret


;! Данил, вот это сразу реализовать после комментов. Вывод строки уже нашего
;формата(см. string.asm) %include можно вставить сверху. Используем пока
;глобальный цвет и курсор. Счетчик тоже оставим 8-бит, чтобы не затрагивать
;дополнительные регистры. Часть уже, если я правильно понял, реализовано в
;демке для процедуры вывода символа.

;Процедура печати грфической строки на экран в режиме Х, по координатам.
;Печать использует глобальные параметры по-умолчанию: позиция, шрифт и т.д.
;При выходе за пределы экрана, выходим тихо.
;Вход:
;AH     биты:
;0..3   масштабирование для символов, 1..16(или можно оставить 1х);
;4      резерв
;5      печатать по одному символу, запомнить глобальные координаты и выйти,
;       чтобы уложиться в один кадр;
;6      останавливать вывод при достижении конца горизонтального вывода;
;7      переносить или нет глобальные координаты печати;
;AL     пока что количество символов для печати, если 0, то печать до конца
;       строки, или пока не закончится экран.
;DS:BX  адрес строки;
;DX     смещение в строке, символ с которого нужно начинать печать.
;Выход: измененный видеобуффер в активной странице и если бит 7, то и курсор.

VXPrintString:
        pushf
        popf
        ret


;Процедура печати графического символа на экран в режим Х, по координатам.
;Пока что использовать шрифт и позицию глобальную, параметры шрифта так же.
;После исполнения сдвигаем позицию слева направо на размер шрифта, если не
;влезает вправо, то переносим на следующую строку, так же по размеру шрифта
;по вертикали.
;Процедура не накладывает никаких ограничений на размер шрифта (например,
;он может не быть кратен 8), кроме одного: ширина символа с учетом
;масштабирования не должна превышать 256 пикселей.
;Вход:
;AL     символ для вывода;
;AH     биты:
;  0..3   масштабирование для символа, 1..16;
;  4..7   резерв, здесь можно стиль вывода будет сделать, задержку,
;         маску и т.д.
;DL     цвет символа
;Выход: измененный видеобуффер в активной странице.

VXPrintChar:
        ; сохраняем регистры, сегментные сохраним позже
        pushf
        push ax
        push bx
        push cx
        push dx
        push si
        push di
        push bp
        cld                             ; направление - вперед

        ; основные параметры отрисовки храним в BX, он не меняется до
        ; выхода из функции:
        ; BL - цвет
        ; BH - битовые параметры (включая масштабирование)
        mov bh,ah
        mov bl,dl

        ; проверяем, есть ли нужный символ в текущем шрифте
        mov cl,[vx_font_first_c]        ; код первого символа в шрифте
        cmp al,cl
        jnb short PrntChr0

;! Отличная схема с явным переходом, но давай если договоримся, что
;последняя метка, которая у нас на выход, просто добавим букву R - return. :)

PrntChrJExit:

        jmp near PrntChrR            ; слишком далеко для условного short
PrntChr0:
        mov dl,[vx_font_chars]          ; количество символов в шрифте
        add dl,cl
        dec dl                          ; DL = код последнего символа
        cmp al,dl
        ja short PrntChrJExit

        ; находим адрес образа нужного символа:
        ; addr = (code-first_code)*symbol_size + font_addr
        mov si,[vx_font_addr + 2]       ; смещение шрифта
        sub al,cl                       ; code - first_code
        mov dl,[vx_font_char_b]         ; ширина символа в байтах
        mul dl
        add si,ax

        mov ch,bh                       ; битовые параметры
        and ch,CHAR_SCALE_MASK        ; выделяем масштабирование
        inc ch                          ; CH = коэфф-т масштабирования

        ; проверяем, можно ли полностью вписать символ в текущую позицию на
        ; экране, если нет - на выход
        mov di,[vx_cursor_x]            ; позиция курсора по X
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        test ax,ax
        jz short PrntChrJExit           ; нулевая ширина, ошибка
        add ax,di                       ; первый пиксель справа после символа
        cmp ax,GFX_SCR_WIDTH            ; не выйдем ли за экран
        ja short PrntChrJExit
        mov dx,[vx_cursor_y]            ; позиция курсора по Y
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; реальная высота с учетом масштаба
        test ax,ax
        jz short PrntChrJExit           ; нулевая высота, ошибка
        add ax,dx                       ; первый пиксель снизу после символа
        cmp ax,GFX_SCR_HEIGHT           ; не выйдем ли за экран
        ja short PrntChrJExit

;! Вот здесь отлично, есть даже формула. Если что не стесняйся оформить её
;прямо слева по краю и комментариями. Это сильно разъясняет, что происходит.
;Или даже можно вынести в заголовок функции в комментарий, по вкусу.

        ; считаем адрес верхнего левого угла символа в видеопамяти:
        ; DI = Y * GFX_BYTES_PER_LINE + (X >> 2) + active_page
        mov ax,dx                       ; Y курсора
        mov dx,GFX_BYTES_PER_LINE
        mul dx
        shr di,1                        ; X курсора >> 2
        shr di,1
        add di,ax
        add di,[vx_scr_active]          ; начало активной видеостраницы

        ; предрасчет смещения вниз на K строк экрана, где K = масштаб
        mov al,ch                       ; масштаб
        mov dl,GFX_BYTES_PER_LINE
        mul dl
        mov bp,ax                       ; сохраняем в BP для использования
                                        ; в цикле потом

        mov ax,[vx_cursor_x]            ; позиция курсора по X
        mov cl,al
        and cl,00000011b
        mov al,00000001b
        shl al,cl
        mov cl,al                       ; CL = маска битовых планов для
                                        ; первого пикселя строки

;!Здесь я сам немного запутался в масштабировании, но всё работает. :)

        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        cmp ax,100h
        ja short PrntChrJExit           ; реальная ширина больше 256, ошибка
        mov ch,al                       ; CH = ширина симв. с учетом масштаба,
                                        ; 0 = 256

        mov dl,[vx_font_height]         ; DL = высота символа, счетчик цикла

        ; сохраняем и заменяем сегментные регистры, после этого доступ к
        ; глобальным переменным будет невозможен
        push ds
        push es
        mov ax,[vx_font_addr]
        mov ds,ax                       ; DS = сегмент шрифта
        mov ax,GFX_SCR_ADDR
        mov es,ax                       ; ES = видеобуфер

        ; AL - битовый буфер для чтения шрифта
        ; AH - текущее количество битов в нем
        mov ah,0

PrntChr1:
        ; рисуем следующую линию шрифта
        push cx                         ; нач. маска и число пикселей в строке
        push dx                         ; счетчик строк
        push di                         ; позиция в видеобуфере

PrntChr2:
        ; формируем маску битовых планов для очередного блока пикселей
        mov dh,0                        ; DH = маска

PrntChr3:
        test ah,ah                      ; есть ли данные в буфере шрифта?
        jnz short PrntChr4

;!Да, флаг нашел, извиняюсь, не увидел в самом начале, всё ок!

        lodsb                           ; читаем очередные 8 бит
        mov ah,08h                      ; bits = 8
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK        ; выделяем масштабирование
        inc dl                          ; DL = счетчик повторов = масштаб
PrntChr4:
        test al,10000000b               ; проверяем очередной бит шрифта

;! Всё верно работает, но можно если что использовать было и сдвиги, если
;данные являются копией и их можно испортить. ROL(SHL) - и бит покидающий
;пределы записывается во флаг переноса и уже можно выплнять переход.

        jz short PrntChr5
        or dh,cl                        ; устанавливаем бит маски
PrntChr5:
        shl cl,1                        ; сдвигаем бит-модификатор маски
        dec dl                          ; счетчик повторов (для масштаба)
        jnz short PrntChr6
        shl al,1                        ; удаляем бит шрифта из буфера
        dec ah                          ; bits-- ?
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK        ; выделяем масштабирование
        inc dl                          ; DL = счетчик повторов = масштаб
PrntChr6:
        dec ch                          ; счетчик пикселей в линии
        jz short PrntChr7               ; закончили линию
        cmp cl,00010000b                ; перешли границу блока?
        jnz short PrntChr3

PrntChr7:
        ; рисуем "столбик" из закрашенных пикселей высотой, равной коэфф-у
        ; масштабирования
        test dh,dh                      ; если маска нулевая, рисовать нечего
        jz short PrntChr8

;! Вот здесь можно использовать VXSetPlanes процедуру из VX_SYS, скорость
;пока что не сильно важна. Она там не оформлена, но всё понятно, или
;если что спрашивай в чате. :) [уже решено в чате].

        push ax
        mov cl,dl                       ; сохраняем счетчик повторов
        mov ah,dh                       ; маска битовых планов
        mov al,02h                      ; адрес регистра VGA
        mov dx,VGA_SEQUENCER_ADDR
        out dx,ax                       ; пишем в регистр маски
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc dl                          ; коэфф-т масштабирования
PrntChr9:
        mov es:[di],bl                  ; пишем в видеобуфер
        add di,GFX_BYTES_PER_LINE       ; переходим на линию ниже
        dec dl
        jnz short PrntChr9              ; следующий пиксель в столбике
        sub di,bp                       ; восстанавливаем позицию
        mov dl,cl                       ; восстанавливаем счетчик повторов
        pop ax

PrntChr8:
        ; переходим к следующему блоку в строке
        inc di                          ; следующий байт в буфере
        mov cl,00000001b                ; сбрасываем позицию в маске
        test ch,ch                      ; сколько пикселей осталось в строке
        jnz short PrntChr2

        ; переходим к следующей строке
        pop di                          ; восстанавливаем позицию в буфере
        pop dx
        pop cx

        add di,bp                       ; на Scale строк вниз
        dec dl                          ; счетчик строк
        jnz short PrntChr1

        ; восстанавливаем сегментные регистры (и доступ к переменным)
        pop es
        pop ds

        ; сдвигаем курсор на ширину символа (с учетом масштаба), проверяем,
        ; влезет ли еще один символ на ту же строку; если нет, спускаемся
        ; на следующую
        mov ch,bh                       ; битовые параметры
        and ch,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc ch                          ; коэфф-т масштабирования
        mov dx,[vx_cursor_x]            ; X курсора
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        add dx,ax                       ; первый пиксель справа после символа
        mov [vx_cursor_x],dx            ; = новая позиция курсора
        add dx,ax                       ; а еще символ влезет?
        cmp dx,GFX_SCR_WIDTH
        jna short PrntChrR              ; если да, то на выход
        mov dx,[vx_cursor_y]            ; Y курсора
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; умножаем на масштаб
        add dx,ax
        mov [vx_cursor_y],dx            ; сдвигаем курсор на строчку ниже
        xor ax,ax
        mov [vx_cursor_x],ax            ; и ставим в начало строки

;!Всё ок, тут только выход и стек. Сделано даже лучше самых смелых ожиданий!:)

PrntChrR:
        pop bp                          ; восстанавливаем регистры
        pop di
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret
