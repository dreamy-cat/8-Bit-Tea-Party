;8-Бит Чаепитие! Лицензия: Creative Commons.
;Платформа: 8086, BIOS, CGA+.
;Инструменты: NASM(2.15).
;Модули: system.asm, screen.asm, clear.asm, print.asm.
;Авторы: Даниил Потапов (danilzatruda23@gmail.com) [1],
;        Александр Серов (funny.dreamy.cat@gmail.com) [2].
;Быстродействие: минимальное при 8-бит числе и прямом порядке - 750 тактов;
;                максимальное при 32-бит числе и обратном порядке - 4060 тактов.
;Память: 106 байт кода и без глобальных данных.

; Задачи:
; - обновить при внедрении модульности, вынести демонстрацию, очистку и печать;
; - подумать над оптимизацией через вывод или смещения бит, слишком много jmp;
; - дополнить вывод с учетом флага только значимых бит числа;
; - 64 бита под вопросом, не совсем понятна применимость.

; Демонстрация и тестирование преобразования данных в бинарное или двоичное
;представление строкового формата. Все 12 возможных комбинаций по флагам.

        org 00100h
Demo:   pushf
        mov ax,00F20h
        mov dl,00000011b
        call near ClearScreen           ;Полная очистка экрана.
        mov si,0004h                    ;4 реализованых сценария по 3 типа
        mov ch,00000000b                ;данных 8-16-32 бита в каждом.
        xor dx,dx
        cld                             ;Не забываем флаг направления.
Demo4:  cmp si,00004h                   ;Всего 4 блока выводов бинарных чисел.
        jnz short Demo1
        lea bx,string_debug             ;Если первая строка, то выводим общую
        xor al,al                       ;информацию об отладке и смещаемся
        call near Print                 ;на пару позиций вниз.
        add dh,002h
        lea bx,string_forward           ;Также выводим на экран наш первый
        call near Print                 ;блок с прямым выводом бит.
        inc dh
Demo1:  cmp si,00002h
        jnz short Demo2
        inc dh
        lea bx,string_backward          ;Если второй блок, то выводим на экран
        call near Print                 ;сообщение, об обратном порядке бит и
        or ch,00001000b                 ;включаем наш флаг.
        inc dh
Demo2:  mov cl,003h                     ;В цикле выводим 8-16-32 бита наших
        lea bx,string_binary            ;заданных чисел, с преобразованием.
Demo3:  mov di,dx
        mov ax,0FEDCh
        mov dx,00F0Ah
        call near BinaryToString        ;Вызов основной процедуры.
        mov dx,di
        xor al,al                       ;Выводим бинарную строку как есть.
        call near Print
        inc dh                          ;Смещаем координату вывода вниз,
        inc ch                          ;увеличиваем тип данных(биты) и
        dec cl                          ;уменьшаем счетчик типов.
        jnz short Demo3
        cmp si,00004h                   ;Далее проверки промежуточного вывода и
        jz short Demo6                  ;определяем, не нужно-ли заполнить
Demo7:  cmp si,00003h                   ;или очистить бинарную строку точками.
        jz short Demo6
        cmp si,0002h
        jnz short Demo5
Demo6:  mov di,bx                       ;Заполняем строку точками, для удобства
        mov bx,cx                       ;восприятия бит при выводе на экран.
        mov al,'.'
        mov cx,[di + STR_LEN_OFFS]
        add di,[di + STR_TEXT_OFFS]
        rep stosb                       ;По прямому флагу напрвления.
        mov cx,bx
        xor ch,00000111b
Demo5:  dec si                          ;Замыкаем цикл и кажется не вмещаемся в
        jz short Demo0                  ;короткий условный переход.
        jmp near Demo4
Demo0:  xor ah,ah                       ;Ожидание нажатия клавиши и выходим.
        int 16h
        popf
        ret

; Процедура преобразования целочисленных данных в бинарное или двоичное
;текстовое представление в формате нашей строки с учетом флагов и размерностей.
; Символы 0 и 1 сохраняются в память по всей длине, в первой версии без учета и
;контроля допустимой длины строки, всё управление на стороне вызова. Проверяется
;только актуальная длина и символы перезаписываются как есть.
; Вход:
;AL     8 бит, целое число без знака;
;AX     16 бит, целое число без знака;
;AX:DX  32 бита, целое число без знака;
;DS:BX  адрес строки назначения;
;CH     биты флагов:
;0..1   размерность операнда в битах, 00: 8 - 11:64 бита;
;2      выравнивание в строке 0 - слева или 1 - справа;
;3      0 - вывод прямой слева старший к правому младшему разряду или обратный;
;4      1 - выводить только значимые разряды или 0 - все с учетом размерности;
;5..7   резерв. 3,4 бит дополнительно, может прямо на вещании сделаем.
;Выход: экран видеобуфера(страницы), все регистры остаются как есть.

BinaryToString:
        pushf                           ;Сохраняем регистр флагов и остальные
        push ax                         ;используемые регистры AX,CX,DX,SI,DI.
        push cx
        push dx
        push si
        push di
        mov cl,ch                       ;Проверяем на допустимость размерность
        and cl,00000011b                ;входных данных, 64 бита не реализовано.
        cmp cl,00000011b
        je short BinStr0
        mov di,ax                       ;Копируем AX и вычисляем количство бит
        mov ax,00008h                   ;для вывода, путем смещения числа 8
        shl ax,cl                       ;влево на младшие 2 бита флагов в CH.
        mov cl,al                       ;CL теперь 8-битный размер строки.
        mov si,ax                       ;SI 16-битный размер для удобства.
        mov ax,di                       ;Восстанавливаем число в AX.
        test ch,00000100b               ;Выравнивание вывода слева или справа.
        jnz short BinStr1
        mov di,[bx + STR_TEXT_OFFS]
        add di,si                       ;Выравнивание смещения в строку слева.
        jmp short BinStr2
BinStr1:mov di,[bx + STR_TEXT_OFFS]
        add di,[bx + STR_LEN_OFFS]      ;Выравнивание смещения в строку справа.
BinStr2:dec di                          ;[DI-1] смещение на первую позицию.
        clc                             ;Сбрасываем флаг переноса для сдвигов.
        test ch,00001000b               ;Проверяем порядок извлечения бит:
        jnz short BinStr4               ;от младших к старшим или наоборот.
        rcr dx,1
        rcr ax,1                        ;Возможно в следующей версии применить
        jmp short BinStr9               ;отдельную процедуру реверса бит.
BinStr4:mov si,cx                       ;Сохраняем флаги и анализируем данные.
        and ch,00000011b                ;Возможна оптимизация через реверс.
        jnz short BinStr5
        rcl al,1                        ;8-ми битное число.
        jmp short BinStrA
BinStr5:cmp ch,00000001b
        jnz short BinStr6
        rcl ax,1                        ;16-ти битное число.
        jmp short BinStrA
BinStr6:rcl ax,1                        ;32-х битное число.
        rcl dx,1
BinStrA:mov cx,si                       ;Восстановим флаги и счетчик.
BinStr9:jc short BinStr7                ;Анализируем флаг переноса и сохраняем
        mov [bx + di],byte '0'          ;заданное значение.
        jmp short BinStr8               ;Посчитать такты и оптимизировать
BinStr7:mov [bx + di],byte '1'          ;без одного перехода.
BinStr8:dec cl                          ;Уменьшаем основной битовый счетчик и
        jnz short BinStr2               ;переходим к следующему символу.
BinStr0:pop di
        pop si
        pop dx
        pop cx
        pop ax                          ;Восстанавливаем все используемые
        popf                            ;общие регистры, флаги и возвращаем
        ret                             ;управление в код вызова.

; Общая строка отладки для заголовка и заданные чисел для проверки результата.
string_debug    dw 00038h
                dw 00004h
                db "Print binary integers 00F0A and 0FEDC in hex with flags."
; Строка для блока вывода слева и справа, в прямом порядке бит.
string_forward  dw 00035h
                dw 00004h
                db "Print binary left-right and right-left, bits forward."
; Строка для блока вывода слева и справа, в обратном порядке бит.
string_backward dw 00036h
                dw 00004h
                db "Print binary left-right and right-left, bits backward."
; Строка назначения для процедуры бинарного преобразования, 32 точки.
string_binary   dw 00020h
                dw 00004h
                db 020h dup ('.')

; Глобальные данные с предустановками временно в этом файле, после в system.asm.

SCR_ADDRESS             EQU 0B800H      ;Адрес буфера экрана CGA+.
SCR_SIZE_BYTE           EQU 00FA0H      ;Размер экрана(страницы) в байтах.
SCR_SIZE_WORD           EQU 007D0H      ;Размер экрана(страницы) в словах.
SCR_WIDTH               EQU 050H        ;Ширина экрана 80 символов, режим 1.
SCR_HEIGHT              EQU 019H        ;Высота экрана 25 символов, режимы 1,3.

STR_LEN_SIZE            EQU 002H        ;Количество байт для размера строки.
STR_LEN_OFFS            EQU 00000H      ;Смещение длины строки от начала адреса.
STR_TEXT_OFFS           EQU 00002H      ;Смещение текста от начала адреса.
STR_TEXT_MAX            EQU -00004H     ;Максимальная длина текста в строке.

scr_cursor_x    db 000h
scr_cursor_y    db 000h
scr_size_word   dw SCR_SIZE_WORD
scr_size_byte   dw SCR_SIZE_BYTE
scr_width       db SCR_WIDTH
scr_height      db SCR_HEIGHT


;30.03.25 [1,2]: Первая версия преобразования числа в двоичную строку и отладка.

; Процедура расширенной печати в стандартный текстовый экран, параметры режима
;располагаются в отдельном файле или в системном заголовке. Формат строки
;уже используем наш, а не стандартный. Выход за пределы буфера или страницы не
;допускается. Отсчет координат стандартный из верхнего левого угла (0, 0),
;смещение +00000h от начального адреса. Контроль корректности строки на
;стороне вызова. Позиция курсора верна и возвращается обновленной.
; Вход:
;AL     биты(флаги) управления:
;0      0 - используются координаты DL-DH или 1 - системного(своего) курсора;
;1      1 - перенос символов на следующую строку запрещён;
;2      1 - строка должна быть напечатана в пределах буфера т.е. постранично;
;3-7    пока что резерв;
;DL     координата по горизонтали в символах, без учета атрибутов;
;DH     координата по вертикали в символах;
;DS:BX  адрес структуры строки;
; Выход:
;AX     количество выведенных символов на экран(в следующую версию).

Print:
        pushf                           ;Сохраняем состояние флагов и активных
        push ax                         ;регистров AX, BX, CX, DX, как и
        push bx                         ;указатель структуры строки.
        push cx
        push dx
        test al,00000001b               ;Проверяем: использовать наш системный
        jz short Print1                 ;курсор или координаты в DL:DH.
        mov dl,[scr_cursor_x]           ;Устанавливаем горизонтальную и
        mov dh,[scr_cursor_y]           ;вертикальную позицию нашего курсора.
Print1: cmp dl,[scr_width]              ;Проверяем, не выходят ли координаты за пределы.
        jnc short Print0                ;пределы размеров экрана и если выходят,
        cmp dh,[scr_height]             ;то завершаем процедуру.
        jnc short Print0
        mov cx,ax                       ;Запоминаем режим печати.
        xor ax,ax                       ;Готовим AX для расчета смещения адреса.
        mov al,dh                       ;Берем вертикальную позицию и
        mul byte [scr_width]            ;рассчитываем смещение по ширине строк.
        xor dh,dh                       ;Обнуляем для сложения смещений.
        add ax,dx                       ;Формируем полный адрес в словах.
        mov dx,di                       ;Сохраняем начальные значение DI.
        mov di,ax                       ;Устанавливаем адрес вывода в буфере.
        test cl,00000010b               ;Проверяем режим построчного вывода и
        jnz short Print2                ;если да, то выводим строку как есть.
        test cl,00000100b               ;Проверяем режим постраничного вывода и
        jnz short Print2                ;если не активен, то проверяем влезет ли
        add ax,[bx + STR_LEN_OFFS]      ;исходная строка во весь экран.
        cmp ax,[scr_size_word]          ;Если строка выходит за предел буфера
        jnbe short Print5               ;экрана, то отменяем вывод совсем.
Print2: mov cx,es                       ;Сохраняем исходный регистр ES и
        mov ax,SCR_ADDRESS              ;устанавливаем сегментный регистр на
        mov es,ax                       ;начало видеобуфера экрана(страницы).
        mov ax,si                       ;Запоминаем исходный регистр SI.
        mov si,bx                       ;Переназначаем указатель SI на строку и
        add si,[bx + STR_TEXT_OFFS]     ;переходим к началу самого текста.
        mov bx,[bx + STR_LEN_OFFS]      ;Извлекаем длину строки в символах.
        cld                             ;Устанавливаем флаг прямого направления.
        shl di,1                        ;Переводим смещение из слов в байты.
Print3: movsb                           ;Копируем символ в видеобуфер.
        inc di                          ;Смещаем назначение на следующий символ.
        cmp di,[scr_size_byte]          ;Контроль выхода за предел буфера.
        jz short Print4                 ;Если достигнут предел, завершаем вывод.
        dec bx                          ;Уменьшаем счетчик символов в строке и
        jnz short Print3                ;продолжаем, если символы еще доступны.
Print4: mov es,cx                       ;Восстанавливаем исходные регистры
        mov si,ax                       ;ES, SI, DI путем копирования.
Print5: mov di,dx
Print0: pop dx                          ;Восстанавливаем общие регистры, флаги
        pop cx                          ;и возвращаем управление.
        pop bx
        pop ax
        popf
        ret

; Процедура очистки текстового буфера экрана. Все параметры режима являются
;внешними переменными. Переменные вынести в системный файл.
; Дополнительно, возможен сброс координат нашего курсора.
; Вход:
;AH     атрибут символа по формату текстового экрана;
;AL     символ для заполнения, стандартный ASCII;
;DL     битовые поля(флаги) дополнительных настроек:
;0      использовать ли символы для заполнения экрана;
;1      использовать ли атрибут при очистки экрана;
;2      сбросить в нули или в начало координат(0,0) наш курсор.
;3-7    резерв.
; Выход: заполнение буфера экрана с учетом настроек(первая страница).

ClearScreen:
        pushf                           ;Сохраняем регистр флагов в стек, а
        push cx                         ;также используемые регистры СХ,DI,ES.
        push di
        push es
        mov cx,[scr_size_word]          ;Загружаем в СХ размер экрана в словах.
        mov di,SCR_ADDRESS              ;Загружаем в ES:DI адрес видеобуфера
        mov es,di                       ;экрана. В ES сегментный адрес, а
        xor di,di                       ;в DI нулевое смещение начала экрана.
        cld                             ;Сбрасываем флаг направления DF(+1).
        test dl,00000001b               ;Бит 0, заполнять-ли экран символами,
        jz short ClrScr1                ;если нет, то проверяем флаг атрибутов.
ClrScr2:stosb                           ;Записываем символ из AL в видеобуфер.
        inc di                          ;Пропускаем байт атрибута, смещение
        loop ClrScr2                    ;на следующий символ и повторяем цикл.
        mov cx,[scr_size_word]          ;Снова в CX размер экрана в словах и
        xor di,di                       ;устанавливаем смещение DI в начало.
ClrScr1:test dl,00000010b               ;Бит 1, заполнять-ли экран атрибутами,
        jz short ClrScr3                ;если нет, то к проверке сброса курсора.
        xchg al,ah                      ;AL содержит атрибут, а AH - символ.
ClrScr4:inc di                          ;Пропускаем символ, увеличивая DI на 1.
        stosb                           ;Записываем байт из AL в видеобуфер и
        loop ClrScr4                    ;повторяем цикл заполения видеобуфера.
        xchg al,ah                      ;Восстанавливаем исходное значение AX.
ClrScr3:test dl,00000100b               ;Проверяем бит сброса курсора в DL.
        jz short ClrScr0
        xor cl,cl                       ;Если бит установлен, то сбрасываем наш
        mov [scr_cursor_x],cl           ;курсор в начальные координаты X:Y(0,0).
        mov [scr_cursor_y],cl
ClrScr0:pop es                          ;Восстанавливаем регистры ES, DI, CX из
        pop di                          ;стека. Также регистр флагов и
        pop cx                          ;возвращаем управление в код вызова.
        popf
        ret
