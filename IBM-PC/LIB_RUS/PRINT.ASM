;8-Бит Чаепитие! Лицензия: Creative Commons.
;Платформа: 8086, BIOS, CGA+.
;Инструменты: NASM(2.15).
;Модули: system.asm, screen.asm.
;Авторы: Даниил Потапов (danilzatruda23@gmail.com) [1],
;        Александр Серов (funny.dreamy.cat@gmail.com) [2].
;Быстродействие: примерно тактов, в/не зависимости от входных параметров.
;Память: байт всего кода и сколько статичных/внешних прямых данных.

; Задачи:
; - обновить процедуру, в соответствии с модульностью библиотеки;
; - дополнительное смещение от начала текста строки.

; Процедура расширенной печати в стандартный текстовый экран, параметры режима
;располагаются в отдельном файле или в системном заголовке. Формат строки
;уже используем наш, а не стандартный. Выход за пределы буфера или страницы не
;допускается. Отсчет координат стандартный из верхнего левого угла (0, 0),
;смещение +00000h от начального адреса. Контроль корректности строки на
;стороне вызова. Позиция курсора верна и возвращается обновленной.
; Вход:
;AL     биты(флаги) управления:
;0      0 - используются координаты DL-DH или 1 - системного(своего) курсора;
;1      1 - перенос символов на следующую строку запрещён;
;2      1 - строка должна быть напечатана в пределах буфера т.е. постранично;
;3-7    пока что резерв;
;DL     координата по горизонтали в символах, без учета атрибутов;
;DH     координата по вертикали в символах;
;DS:BX  адрес структуры строки;
; Выход:
;AX     количество выведенных символов на экран(в следующую версию).

Print:
        pushf                           ;Сохраняем состояние флагов и активных
        push ax                         ;регистров AX, BX, CX, DX, как и
        push bx                         ;указатель структуры строки.
        push cx
        push dx
        test al,00000001b               ;Проверяем: использовать наш системный
        jz short Print1                 ;курсор или координаты в DL:DH.
        mov dl,[scr_cursor_x]           ;Устанавливаем горизонтальную и
        mov dh,[scr_cursor_y]           ;вертикальную позицию нашего курсора.
Print1: cmp dl,[scr_width]              ;Проверяем, не выходят ли координаты за пределы.
        jnc short Print0                ;пределы размеров экрана и если выходят,
        cmp dh,[scr_height]             ;то завершаем процедуру.
        jnc short Print0
        mov cx,ax                       ;Запоминаем режим печати.
        xor ax,ax                       ;Готовим AX для расчета смещения адреса.
        mov al,dh                       ;Берем вертикальную позицию и
        mul byte [scr_width]            ;рассчитываем смещение по ширине строк.
        xor dh,dh                       ;Обнуляем для сложения смещений.
        add ax,dx                       ;Формируем полный адрес в словах.
        mov dx,di                       ;Сохраняем начальные значение DI.
        mov di,ax                       ;Устанавливаем адрес вывода в буфере.
        test cl,00000010b               ;Проверяем режим построчного вывода и
        jnz short Print2                ;если да, то выводим строку как есть.
        test cl,00000100b               ;Проверяем режим постраничного вывода и
        jnz short Print2                ;если не активен, то проверяем влезет ли
        add ax,[bx + STR_LEN_OFFS]      ;исходная строка во весь экран.
        cmp ax,[scr_size_word]          ;Если строка выходит за предел буфера
        jnbe short Print5               ;экрана, то отменяем вывод совсем.
Print2: mov cx,es                       ;Сохраняем исходный регистр ES и
        mov ax,SCR_ADDRESS              ;устанавливаем сегментный регистр на
        mov es,ax                       ;начало видеобуфера экрана(страницы).
        mov ax,si                       ;Запоминаем исходный регистр SI.
        mov si,bx                       ;Переназначаем указатель SI на строку и
        add si,[bx + STR_TEXT_OFFS]     ;переходим к началу самого текста.
        mov bx,[bx + STR_LEN_OFFS]      ;Извлекаем длину строки в символах.
        cld                             ;Устанавливаем флаг прямого направления.
        shl di,1                        ;Переводим смещение из слов в байты.
Print3: movsb                           ;Копируем символ в видеобуфер.
        inc di                          ;Смещаем назначение на следующий символ.
        cmp di,[scr_size_byte]          ;Контроль выхода за предел буфера.
        jz short Print4                 ;Если достигнут предел, завершаем вывод.
        dec bx                          ;Уменьшаем счетчик символов в строке и
        jnz short Print3                ;продолжаем, если символы еще доступны.
Print4: mov es,cx                       ;Восстанавливаем исходные регистры
        mov si,ax                       ;ES, SI, DI путем копирования.
Print5: mov di,dx
Print0: pop dx                          ;Восстанавливаем общие регистры, флаги
        pop cx                          ;и возвращаем управление.
        pop bx
        pop ax
        popf
        ret

%include "screen.asm"

;23.03.25 [1,2]: Первый рабочий вариант печати с флагами и демонстрацией.
;17.03.25 [1,2]: Первый вариант черновика и сценарии отладки.
