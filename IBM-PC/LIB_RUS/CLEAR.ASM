;8-Бит Чаепитие! Лицензия: Creative Commons.
;Платформа: 8086, BIOS, CGA+.
;Инструменты: NASM(2.15).
;Модули: system.asm.
;Авторы: Даниил Потапов (danilzatruda23@gmail.com) [1],
;        Александр Серов (funny.dreamy.cat@gmail.com) [2].
;Быстродействие: примерно тактов, в/не зависимости от входных параметров.
;Память: байт всего кода и сколько статичных/внешних прямых данных.


CPU 8086

; Процедура очистки текстового буфера экрана. Все параметры режима являются
;внешними переменными. Переменные вынести в системный файл.
; Дополнительно, возможен сброс координат нашего курсора.
; Вход:
;AH   атрибут символа по формату текстового экрана.
;AL   символ для заполнения.
;DL   битовые поля дополнительных настроек:
;0    использовать ли символы для заполнения.
;1    использовать ли атрибут при очистки ДА/НЕТ.
;2    сбросить в нули или в начало координат(0,0) наш курсор.
;3-7  резерв.
; Выход: заполнение буфера экрана с учетом настроек.

ClearScreen:
        pushf                           ;Сохраняем регистры флагов в стек.
        push cx                         ;Сохраняем регистр СХ в стек.
        push di                         ;Сохраняем регистр DI в стек.
        push es                         ;Сохраняем регистр ES в стек.
        mov cx,[scr_size_word]          ;Загружаем в СХ размер экрана в словах.
        mov di,SCR_ADDRESS              ;Загружаем в DI адрес видебуфера.
        mov es,di                       ;Перемещаем значение DI в ES.
        xor di,di                       ;Обнуляем смещение в сегменте видеобуфера в DI.
        cld                             ;Сбрасываем флаг направления DF.
        test dl,00000001b               ;Проверяем бит 0 в DL.
        jz short ClrScr2                ;Если бит 0 не установлен, переходим к метке ClrScr2.
ClrScr1:stosb                           ;Записываем байт из AL в видеобуфер, увеличиваем DI.
        inc di                          ;Пропускаем байт атрибута, увеличивая DI на 1.
        loop ClrScr1                    ;Повторяем цикл заполение видеобуфера, пока CX не станет 0.
        mov cx,[scr_size_word]          ;Снова загружаем в CX размер экрана в словах.
        xor di,di                       ;Обнуляем смещение в сегменте видеобуфера в DI.
ClrScr2:test dl,00000010b               ;Проверяем бит 1 в DL.
        jz short ClrScr0                ;Если бит 1 не установлен, переходим к метке ClrScr0.
        xchg al,ah                      ;Меняем местами AL и AH. AL теперь содержит атрибут, а AH - символ.
        inc di                          ;Пропускаем байт символа, увеличивая DI на 1.
ClrScr3:stosb                           ;Записываем байт из AL в видеобуфер, увеличиваем DI.
        inc di                          ;Пропускаем байт символа, увеличивая DI на 1.
        loop ClrScr3                    ;Повторяем цикл заполение видеобуфера, пока CX не станет 0.
        xchg al,ah                      ;Меняем местами AL и AH. Восстанавливаем исходные значения.
ClrScr0:test dl,00000100b               ;Проверяем бит 2 в DL.
        jz short ClrScr4                ;Если бит 2 не установлен, переходим к метке ClrScr4.
        xor cl,cl                       ;
        mov [scr_cursor_x], cl          ;Сбрасываем координату X курсора в 0.
        mov [scr_cursor_y], cl          ;Сбрасываем координату Y курсора в 0.
ClrScr4:pop es                          ;Восстанавливаем регистр ES из стека.
        pop di                          ;Восстанавливаем регистр DI из стека.
        pop cx                          ;Восстанавливаем регистр CX из стека.
        popf                            ;Восстанавливаем регистр флагов из стека.
        ret                             ;Завершаем процедуру и возвращаем управление.


%include "screen.asm"

;22.03.25, [1]: Первая версия отчистки готова, дополнена сбросом курсора.
;17.03.25, [1,2]: 1 версия черновика с отваленным вещанием и дополнением.