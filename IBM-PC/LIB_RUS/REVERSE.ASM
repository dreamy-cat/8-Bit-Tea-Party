;8-Бит Чаепитие! Лицензия: Creative Commons.
;Платформа: 8086, BIOS, CGA+.
;Инструменты: NASM(2.15).
;Модули: system.asm, screen.asm, clear.asm, print.asm.
;Авторы: Даниил Потапов (danilzatruda23@gmail.com) [1],
;        Александр Серов (funny.dreamy.cat@gmail.com) [2].
;Быстродействие: минимальное при 16-бит регистре и сдвигах, 284 тактов;
;                максимальное при 8-бит регистре и масками, 820 тактов.
;Память: 118 байт кода и без глобальных данных.

; Задачи:
; - обновить при внедрении модульности, вынести демонстрацию, очистку и печать;
; - дополнить демонстрацию немного комментариями при выводе на экран;
; - 64 бита под вопросом, не совсем понятна применимость, но можно через память.

; Демонстрация и тестирование преобразования реверса данных в двоичном
;представлении. Вывод в формате строк всех размерностей 8-16-32 бита.

CPU 8086

        org 00100h                      ;Смещение всех адресов для .COM файла с
        pushf                           ;минимальным сохранением флагов.
        mov ax,00F20h                   ;Очистка экрана черным фоном и ярким
        mov dl,00000011b                ;белым текстом.
        call near ClearScreen
        xor al,al                       ;Заглавный текст, с описанием кода и
        mov bx,str_reverse              ;данными, которые тестируются.
        xor dx,dx
        call near Print
        mov cl,00Eh                     ;Всего 14 тестовых данных 8-16-32 бита.
        mov bp,00500h                   ;Стартовые позиции вывода после текста.
        lea si,debug_byte
        lea bx,str_reverse              ;Строка шаблон для вывода бинарных
        cld                             ;данных и флаг направления.
Demo4:  cmp cl,06h                      ;Первые 8 данных по 8 бит.
        jbe short Demo1
        jnz short DemoA
        add bp,00100h                   ;Смещаем координату ниже, для отступа.
DemoA:  lodsb                           ;8-бит загрузка данных из таблицы и
        mov ch,00000000b                ;установка флага конвертации.
        jmp short Demo2
Demo1:  jnz short DemoB
        add bp,00100h
DemoB:  cmp cl,001h
        jbe short Demo3
        lodsw                           ;Загружаем 16-битные данные и установка
        mov ch,00000001b                ;параметра преобразования.
        jmp short Demo2
Demo3:  jnz short DemoC
        add bp,00100h                   ;Отделяем последние данные в 32 бита.
DemoC:  lodsw                           ;Загружаем сначала младшие 16-ть бит
        mov dx,[si]                     ;в регистр AX и старшую в DX.
        add si,02h
        mov ch,00000010b                ;Смещаем данные и настройки.
Demo2:  lea bx,str_binary               ;Строка для бинарного вывода.
        mov di,cx
        mov cl,08h                      ;Вычисляем количество бит, необходимых
        xchg cl,ch                      ;для преобразования в строку.
        shl ch,cl
        xchg ch,cl
        xor ch,ch
        mov [bx],cx                     ;Сохраняем длину строки прямо в начало.
        mov cx,di
        call near BinaryToString
        push ax
        push dx
        mov dx,bp                       ;Координаты для вывода из регистра BP.
        xor al,al
        call near Print
        add bp,[bx]                     ;Смещаем курсор вправо и плюс
        add bp,00004h                   ;разделитель.
        pop dx
        pop ax
        call near ReverseBits           ;Реверс бит и преобразование данных в
        call near BinaryToString        ;строку для вывода.
        push ax
        push dx
        mov dx,bp
        xor al,al
        call near Print
        sub bp,[bx]                     ;Смещаемся снова влево и строчкой ниже.
        sub bp,00004h
        add bp,00100h
        pop dx
        pop ax
        dec cl
        ;cmp cl,05h                     ;Для отладки ограничитель вывода.
        jnz short Demo4                 ;Основной цикл.
Demo0:  xor ah,ah                       ;Ожидание клавиши и выходим.
        int 16h
        popf
        ret

; Отладочные данные, 8-16-32 бита соответственно, симметричные и ассиметричные.
debug_byte      db 000h, 0FFh, 001h, 080h, 081h, 055h, 0AAh, 05Ah
debug_word      dw 00000h, 0FFFFh, 08001h, 05185h, 055AAh
debug_dword     dd 0FA518A50h

str_reverse     dw 00128h               ;Информационная строка.
                dw 00004h
                db " Procedure reverse bits in registers AL,AX and AX:DX. "
                db "Using masks and logicals instructions for 8-bit data. "
                db "Or using cycle rols with carry flag for 16-32 bits. "
                db "Bytes for debug: 000h, 0FFh, 001h, 080h, 081h, 055h, "
                db "0AAh, 05Ah. Words: 00000h, 0FFFFh, 08001h, 05185h, 055AAh. "
                db "Double word: 0FA518A50h."

str_binary      dw 00020h               ;Шаблон под бинарную строку вывода.
                dw 00004h
                db 020h dup ('.')

; Процедура реверса или изменения порядка бит в регистрах на обратный, т.е.
;самый младший бит становится старшим и наоборот. Содержимое регистров не имеет
;значения. 64 бита не поддерживается, флаги и оставшиеся регистры остаются
;без изменений.
; Вход:
;AL     8 бит;
;AX     16 бит;
;DX:AX  32 бита;
;CH     биты флагов:
;0..1   размерность операнда в битах, 00: 8 - 11:64 бита;
; Выход: изменение исходных регистров данных.

ReverseBits:
        pushf                           ;Сохраняем флаги и общие регистры.
        push bx                         ;Не сохраняем и/или не используем
        push cx                         ;регистры с данными.
        push si
        push di
        mov cl,ch
        and ch,00000011b                ;Оставляем только значимые биты размера.
        cmp ch,00000011b
        jz short RevBit0                ;Если 64-бита, то завершаем процедуру.
        test ch,ch
        jnz short RevBit1               ;Проверяем режим 8 бит или 16/32.
        mov cl,008h                     ;Количество бит для перестановки.
        mov bl,10000000b                ;Маска для старшего 7-ого бита.
RevBit2:dec cl                          ;Цикл обмена битами, уменьшаем счетчик.
        mov bh,al                       ;Копируем текущее значение AL в BH.
        and bh,bl                       ;Получаем значение левого бита по маске.
        not bl                          ;Инвертируем побитово маску BL.
        and al,bl                       ;Сбрасываем левый бит в AL.
        not bl                          ;Восстанавливаем исходную маску.
        shr bh,cl                       ;Сдвигаем левый бит в правую позицию.
        shr bl,cl                       ;Готовим маску для правого бита.
        mov ch,al                       ;Копируем текущее значение AL в BH.
        and ch,bl                       ;Получаем значение правого бита.
        shl ch,cl                       ;Сдвигаем правый бит в левую позицию.
        not bl                          ;Инвертируем побитово маску BL,
        and al,bl                       ;сбрасываем правый бит в AL и
        not bl                          ;восстанавливаем маску.
        or al,bh                        ;Устанавливаем левый бит в правую
        or al,ch                        ;позицию и наоборот правый в левую.
        dec cl                          ;Уменьшаем счетчик для пары битов.
        shl bl,cl                       ;Сдвигаем маску для следующего бита.
        test cl,cl
        jnz short RevBit2               ;Проверяем счетчик и повторяем цикл или
        jmp short RevBit0               ;выходим из процедуры, AH не изменен.
RevBit1:cmp ch,00000001b                ;Проверяем, 16-битный ли режим регистра
        jnz short RevBit3               ;и если нет, то остается 32-битный.
        xor bx,bx                       ;Обнуляем BX для сохранения результата.
        mov cl,008h                     ;Количество сдвигов в цикле 16/2.
RevBit4:shl ah,1                        ;Смещаем старший бит из AH в флаг CF и
        rcr bl,1                        ;вращаем бит CF в старший бит BL.
        shl al,1                        ;Аналогично смещаем биты в AL и BH.
        rcr bh,1
        dec cl                          ;Уменьшаем счетчик итераций и повторяем
        jnz short RevBit4               ;для оставшихся битов регистра.
        mov ax,bx                       ;Сохраняем результат в AX и выходим.
        jmp short RevBit0
RevBit3:xor si,si                       ;Обнуляем SI и DI для старшей и младшей
        xor di,di                       ;части результата, счетчик 32/2 бита.
        mov cl,010h
RevBit5:shl dx,1                        ;Смещаем старший бит из DX в флаг CF и
        rcr si,1                        ;вращаем бит CF в старший бит SI, также
        shl ax,1                        ;аналогично для регистров AX и DI.
        rcr di,1
        dec cl                          ;Уменьшаем счетчик итераций и повторяем
        jnz short RevBit5               ;для оставшихся битов регистров.
        mov ax,si                       ;Сохраняем реверсивные регистры SI, DI
        mov dx,di                       ;в исходные данные регистров DX:AX.
RevBit0:pop di
        pop si
        pop cx
        pop bx
        popf                            ;Восстанавливаем флаги, регистры и
        ret                             ;возврат из процедуры.

; Процедура очистки текстового буфера экрана. Все параметры режима являются
;внешними переменными. Переменные вынести в системный файл.
; Дополнительно, возможен сброс координат нашего курсора.
; Вход:
;AH     атрибут символа по формату текстового экрана;
;AL     символ для заполнения, стандартный ASCII;
;DL     битовые поля(флаги) дополнительных настроек:
;0      использовать ли символы для заполнения экрана;
;1      использовать ли атрибут при очистки экрана;
;2      сбросить в нули или в начало координат(0,0) наш курсор.
;3-7    резерв.
; Выход: заполнение буфера экрана с учетом настроек(первая страница).

ClearScreen:
        pushf                           ;Сохраняем регистр флагов в стек, а
        push cx                         ;также используемые регистры СХ,DI,ES.
        push di
        push es
        mov cx,[scr_size_word]          ;Загружаем в СХ размер экрана в словах.
        mov di,SCR_ADDRESS              ;Загружаем в ES:DI адрес видеобуфера
        mov es,di                       ;экрана. В ES сегментный адрес, а
        xor di,di                       ;в DI нулевое смещение начала экрана.
        cld                             ;Сбрасываем флаг направления DF(+1).
        test dl,00000001b               ;Бит 0, заполнять-ли экран символами,
        jz short ClrScr1                ;если нет, то проверяем флаг атрибутов.
ClrScr2:stosb                           ;Записываем символ из AL в видеобуфер.
        inc di                          ;Пропускаем байт атрибута, смещение
        loop ClrScr2                    ;на следующий символ и повторяем цикл.
        mov cx,[scr_size_word]          ;Снова в CX размер экрана в словах и
        xor di,di                       ;устанавливаем смещение DI в начало.
ClrScr1:test dl,00000010b               ;Бит 1, заполнять-ли экран атрибутами,
        jz short ClrScr3                ;если нет, то к проверке сброса курсора.
        xchg al,ah                      ;AL содержит атрибут, а AH - символ.
ClrScr4:inc di                          ;Пропускаем символ, увеличивая DI на 1.
        stosb                           ;Записываем байт из AL в видеобуфер и
        loop ClrScr4                    ;повторяем цикл заполения видеобуфера.
        xchg al,ah                      ;Восстанавливаем исходное значение AX.
ClrScr3:test dl,00000100b               ;Проверяем бит сброса курсора в DL.
        jz short ClrScr0
        xor cl,cl                       ;Если бит установлен, то сбрасываем наш
        mov [scr_cursor_x],cl           ;курсор в начальные координаты X:Y(0,0).
        mov [scr_cursor_y],cl
ClrScr0:pop es                          ;Восстанавливаем регистры ES, DI, CX из
        pop di                          ;стека. Также регистр флагов и
        pop cx                          ;возвращаем управление в код вызова.
        popf
        ret

; Процедура преобразования целочисленных данных в бинарное или двоичное
;текстовое представление в формате нашей строки с учетом флагов и размерностей.
; Символы 0 и 1 сохраняются в память по всей длине, в первой версии без учета и
;контроля допустимой длины строки, всё управление на стороне вызова. Проверяется
;только актуальная длина и символы перезаписываются как есть.
; Вход:
;AL     8 бит, целое число без знака;
;AX     16 бит, целое число без знака;
;AX:DX  32 бита, целое число без знака;
;DS:BX  адрес строки назначения;
;CH     биты флагов:
;0..1   размерность операнда в битах, 00: 8 - 11:64 бита;
;2      выравнивание в строке 0 - слева или 1 - справа;
;3      0 - вывод прямой слева старший к правому младшему разряду или обратный;
;4      1 - выводить только значимые разряды или 0 - все с учетом размерности;
;5..7   резерв. 3,4 бит дополнительно, может прямо на вещании сделаем.
;Выход: экран видеобуфера(страницы), все регистры остаются как есть.

BinaryToString:
        pushf                           ;Сохраняем регистр флагов и остальные
        push ax                         ;используемые регистры AX,CX,DX,SI,DI.
        push cx
        push dx
        push si
        push di
        mov cl,ch                       ;Проверяем на допустимость размерность
        and cl,00000011b                ;входных данных, 64 бита не реализовано.
        cmp cl,00000011b
        je short BinStr0
        mov di,ax                       ;Копируем AX и вычисляем количство бит
        mov ax,00008h                   ;для вывода, путем смещения числа 8
        shl ax,cl                       ;влево на младшие 2 бита флагов в CH.
        mov cl,al                       ;CL теперь 8-битный размер строки.
        mov si,ax                       ;SI 16-битный размер для удобства.
        mov ax,di                       ;Восстанавливаем число в AX.
        test ch,00000100b               ;Выравнивание вывода слева или справа.
        jnz short BinStr1
        mov di,[bx + STR_TEXT_OFFS]
        add di,si                       ;Выравнивание смещения в строку слева.
        jmp short BinStr2
BinStr1:mov di,[bx + STR_TEXT_OFFS]
        add di,[bx + STR_LEN_OFFS]      ;Выравнивание смещения в строку справа.
BinStr2:dec di                          ;[DI-1] смещение на первую позицию.
        clc                             ;Сбрасываем флаг переноса для сдвигов.
        test ch,00001000b               ;Проверяем порядок извлечения бит:
        jnz short BinStr4               ;от младших к старшим или наоборот.
        rcr dx,1
        rcr ax,1                        ;Возможно в следующей версии применить
        jmp short BinStr9               ;отдельную процедуру реверса бит.
BinStr4:mov si,cx                       ;Сохраняем флаги и анализируем данные.
        and ch,00000011b                ;Возможна оптимизация через реверс.
        jnz short BinStr5
        rcl al,1                        ;8-ми битное число.
        jmp short BinStrA
BinStr5:cmp ch,00000001b
        jnz short BinStr6
        rcl ax,1                        ;16-ти битное число.
        jmp short BinStrA
BinStr6:rcl ax,1                        ;32-х битное число.
        rcl dx,1
BinStrA:mov cx,si                       ;Восстановим флаги и счетчик.
BinStr9:jc short BinStr7                ;Анализируем флаг переноса и сохраняем
        mov [bx + di],byte '0'          ;заданное значение.
        jmp short BinStr8               ;Посчитать такты и оптимизировать
BinStr7:mov [bx + di],byte '1'          ;без одного перехода.
BinStr8:dec cl                          ;Уменьшаем основной битовый счетчик и
        jnz short BinStr2               ;переходим к следующему символу.
BinStr0:pop di
        pop si
        pop dx
        pop cx
        pop ax                          ;Восстанавливаем все используемые
        popf                            ;общие регистры, флаги и возвращаем
        ret                             ;управление в код вызова.
        
; Процедура расширенной печати в стандартный текстовый экран, параметры режима
;располагаются в отдельном файле или в системном заголовке. Формат строки
;уже используем наш, а не стандартный. Выход за пределы буфера или страницы не
;допускается. Отсчет координат стандартный из верхнего левого угла (0, 0),
;смещение +00000h от начального адреса. Контроль корректности строки на
;стороне вызова. Позиция курсора верна и возвращается обновленной.
; Вход:
;AL     биты(флаги) управления:
;0      0 - используются координаты DL-DH или 1 - системного(своего) курсора;
;1      1 - перенос символов на следующую строку запрещён;
;2      1 - строка должна быть напечатана в пределах буфера т.е. постранично;
;3-7    пока что резерв;
;DL     координата по горизонтали в символах, без учета атрибутов;
;DH     координата по вертикали в символах;
;DS:BX  адрес структуры строки;
; Выход:
;AX     количество выведенных символов на экран(в следующую версию).

Print:
        pushf                           ;Сохраняем состояние флагов и активных
        push ax                         ;регистров AX, BX, CX, DX, как и
        push bx                         ;указатель структуры строки.
        push cx
        push dx
        test al,00000001b               ;Проверяем: использовать наш системный
        jz short Print1                 ;курсор или координаты в DL:DH.
        mov dl,[scr_cursor_x]           ;Устанавливаем горизонтальную и
        mov dh,[scr_cursor_y]           ;вертикальную позицию нашего курсора.
Print1: cmp dl,[scr_width]              ;Проверяем, не выходят ли координаты за пределы.
        jnc short Print0                ;пределы размеров экрана и если выходят,
        cmp dh,[scr_height]             ;то завершаем процедуру.
        jnc short Print0
        mov cx,ax                       ;Запоминаем режим печати.
        xor ax,ax                       ;Готовим AX для расчета смещения адреса.
        mov al,dh                       ;Берем вертикальную позицию и
        mul byte [scr_width]            ;рассчитываем смещение по ширине строк.
        xor dh,dh                       ;Обнуляем для сложения смещений.
        add ax,dx                       ;Формируем полный адрес в словах.
        mov dx,di                       ;Сохраняем начальные значение DI.
        mov di,ax                       ;Устанавливаем адрес вывода в буфере.
        test cl,00000010b               ;Проверяем режим построчного вывода и
        jnz short Print2                ;если да, то выводим строку как есть.
        test cl,00000100b               ;Проверяем режим постраничного вывода и
        jnz short Print2                ;если не активен, то проверяем влезет ли
        add ax,[bx + STR_LEN_OFFS]      ;исходная строка во весь экран.
        cmp ax,[scr_size_word]          ;Если строка выходит за предел буфера
        jnbe short Print5               ;экрана, то отменяем вывод совсем.
Print2: mov cx,es                       ;Сохраняем исходный регистр ES и
        mov ax,SCR_ADDRESS              ;устанавливаем сегментный регистр на
        mov es,ax                       ;начало видеобуфера экрана(страницы).
        mov ax,si                       ;Запоминаем исходный регистр SI.
        mov si,bx                       ;Переназначаем указатель SI на строку и
        add si,[bx + STR_TEXT_OFFS]     ;переходим к началу самого текста.
        mov bx,[bx + STR_LEN_OFFS]      ;Извлекаем длину строки в символах.
        cld                             ;Устанавливаем флаг прямого направления.
        shl di,1                        ;Переводим смещение из слов в байты.
Print3: movsb                           ;Копируем символ в видеобуфер.
        inc di                          ;Смещаем назначение на следующий символ.
        cmp di,[scr_size_byte]          ;Контроль выхода за предел буфера.
        jz short Print4                 ;Если достигнут предел, завершаем вывод.
        dec bx                          ;Уменьшаем счетчик символов в строке и
        jnz short Print3                ;продолжаем, если символы еще доступны.
Print4: mov es,cx                       ;Восстанавливаем исходные регистры
        mov si,ax                       ;ES, SI, DI путем копирования.
Print5: mov di,dx
Print0: pop dx                          ;Восстанавливаем общие регистры, флаги
        pop cx                          ;и возвращаем управление.
        pop bx
        pop ax
        popf
        ret

;Глобальные константы и системные переменные, временно.

SCR_ADDRESS             EQU 0B800H      ;Адрес буфера экрана CGA+.
SCR_WIDTH               EQU 050H        ;Ширина экрана 80 символов, режим 1.
SCR_HEIGHT              EQU 019H        ;Высота экрана 25 символов, режимы 1,3.
SCR_WIDTH_BYTE          EQU 0A0H        ;Количество байт на каждую линию.
SCR_WIDTH_WORD          EQU 050H        ;Количество слов на каждую линию.
SCR_SIZE_BYTE           EQU 00FA0H      ;Размер экрана(страницы) в байтах.
SCR_SIZE_WORD           EQU 007D0H      ;Размер экрана(страницы) в словах.

STR_LEN_SIZE            EQU 002H        ;Количество байт для размера строки.
STR_LEN_OFFS            EQU 00000H      ;Смещение длины строки от начала адреса.
STR_TEXT_OFFS           EQU 00002H      ;Смещение текста от начала адреса.
STR_TEXT_MAX            EQU -00004H     ;Максимальная длина текста в строке.

scr_width       db SCR_WIDTH
scr_height      db SCR_HEIGHT
scr_size_word   dw SCR_SIZE_WORD
scr_cursor_x    db 000h
scr_cursor_y    db 000h
scr_size_byte   dw SCR_SIZE_BYTE

;19.04.2025 [1,2]: Код демонстрации с отладкой всех вариантов реверса бит.
;18.04.2025 [1,2]: Базовый черновик без демонстрации, сама процедура с отладкой.
