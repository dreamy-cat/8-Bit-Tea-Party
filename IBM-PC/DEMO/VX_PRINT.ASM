;8-Бит Чаепитие! 2021.
;Лицензия: Creative Commons.
;Платформа: 8086, VGA(256Kb).
;Инструменты: NASM.
;Модули: VGA-X,...
;Авторы: Данила Перов(peroff@protonmail.com).
;Быстродействие: примерное количество тактов для каждой процедуры.
;Память: процед_1 = N, процед_2 занимает М байт.
;Краткая история изменений:
;ДД.ММ.ГГ, И.И.: Короткое сообщение что добавлено, удалено или исправлено.

%include "VGA-X.ASM"            ;Директива включения заголовка для NASM.

;Полный комплект, при условии если всё ок, то до 13-20 ноября.
;Базовый вариант, через недельку-две-три, буква.

;Процедуры печати в экранную память режима Х, нашего 16-ти битного формата
;строк. Смотри файл string.asm для подробного описания формата.
;Использует дополнительно пару глобальных параметров: шрифт по умолчанию и
;текущие позиции вывода для удобства вызовов. Для старта можно взять пока
;системный шрифт ВГА адаптера. Его можно получить при вызове функции.
;Шрифт минимально черно-белый размеры были по умолчанию 8*8.


;Глобальные переменные и константы, когда будет доделано, то скинем их в
;общий файл библиотеки режима Х.


;Биты, задающие масштаб, в параметрах функций VXPrintChar и VXPrintString
CHAR_SCALE_MASK         EQU 00001111b


vx_cursor_x     dw 0000h        ;Левая точка позиции курсора, 0..319.
vx_cursor_y     dw 0000h        ;Верхняя точка позиции курсора, 0..239.
vx_font_addr    dd 00000000h    ;Полный адрес шрифта, смещение и сегмент.
vx_font_first_c db 00h          ;Код первого символа в шрифте.
vx_font_chars   db 00h          ;Количество символов в шрифте, 0 = 256.
vx_font_char_b  db 00h          ;Количество байт на один символ.
vx_font_width   db 00h          ;Ширина символа в точках.
vx_font_height  db 00h          ;Высота символа в линиях.


;Если потребуются вспомогательные процедуры работы со шрифтом, то добавляй
;временно прямо сюда, если что подумаем позже об отдельном файле. VXFontLoad.

;Загружаем в глобальные переменные адрес и прочие данные системного шрифта
;по умолчанию, размер: 8x8.
;Вход:  нет;
;Выход: измененные глобальные переменные vx_font_*

VXLoadFontBIOS:
        pushf
        push ax
        push bx
        push cx
        push dx
        push bp
        push es

        mov ax,1130h                    ; получить параметры шрифта из BIOS
        mov bh,3                        ; выбираем шрифт 8x8
        int 10h
        mov ax,es
        mov [vx_font_addr],ax           ; сегмент данных шрифта
        mov [vx_font_addr + 2],bp       ; смещение данных шрифта
        mov byte [vx_font_chars],0      ; количество символов в шрифте, 0=256
        mov byte [vx_font_char_b],8     ; байтов на один символ
        mov byte [vx_font_width],8      ; ширина символа
        mov byte [vx_font_height],8     ; высота символа

        pop es
        pop bp
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret

;Дополнительно, только если уже ниже процедуры реализованы.
;Всё по аналогии, только с учетом вывода в окно.
;Параметры пока подумаем, но главное, что бы вывод шел с ограничением
;относительно логического окна, а не экрана и плюс с разными дополнительными
;возможностями.

VXPrintStrWin:
        pushf
        popf
        ret


;Процедура печати грфической строки на экран в режиме Х, по координатам.
;Печать использует глобальные параметры по-умолчанию: позиция, шрифт и т.д.
;При выходе за пределы экрана, выходим тихо.
;Вход:
;AH     биты:
;0..2   масштабирование для символов, 1..8(сначала просто масштаб 1х);
;4      резерв
;5      печатать по одному символу, запомнить состояние и выйти, чтобы
;       уложится в один кадр;
;6      останавливать вывод при достижении конца горизонтального вывода;
;7      переносить или нет глобальные координаты печати;
;DS:BX  адрес строки;
;Выход: измененный видеобуффер в активной странице и если бит 7, то и курсор.

VXPrintString:
        pushf
        popf
        ret


;Процедура печати графического символа на экран в режим Х, по координатам.
;Пока что использовать шрифт и позицию глобальную, параметры шрифта так же.
;После исполнения сдвигаем позицию слева направо на размер шрифта, если не
;влезает вправо, то переносим на следующую строку, так же по размеру шрифта
;по вертикали.
;Процедура не накладывает никаких ограничений на размер шрифта (например,
;он может не быть кратен 8), кроме одного: ширина символа с учетом
;масштабирования не должна превышать 256 пикселей.
;Вход:
;AL     символ для вывода;
;AH     биты:
;  0..3   масштабирование для символа, 1..16;
;  4..7   резерв, здесь можно стиль вывода будет сделать, задержку,
;         маску и т.д.
;DL     цвет символа
;Выход: измененный видеобуффер в активной странице.

VXPrintChar:
        ; сохраняем регистры, сегментные сохраним позже
        pushf
        push ax
        push bx
        push cx
        push dx
        push si
        push di
        push bp
        cld                             ; направление - вперед

        ; основные параметры отрисовки храним в BX, он не меняется до
        ; выхода из функции:
        ; BL - цвет
        ; BH - битовые параметры (включая масштабирование)
        mov bh,ah
        mov bl,dl

        ; проверяем, есть ли нужный символ в текущем шрифте
        mov cl,[vx_font_first_c]        ; код первого символа в шрифте
        cmp al,cl
        jnb short PrntChr0
PrntChrJExit:
        jmp near PrntChrExit            ; слишком далеко для условного short
PrntChr0:
        mov dl,[vx_font_chars]          ; количество символов в шрифте
        add dl,cl
        dec dl                          ; DL = код последнего символа
        cmp al,dl
        ja short PrntChrJExit

        ; находим адрес образа нужного символа:
        ; addr = (code-first_code)*symbol_size + font_addr
        mov si,[vx_font_addr + 2]       ; смещение шрифта
        sub al,cl                       ; code - first_code
        mov dl,[vx_font_char_b]         ; ширина символа в байтах
        mul dl
        add si,ax

        mov ch,bh                       ; битовые параметры
        and ch,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc ch                          ; CH = коэфф-т масштабирования

        ; проверяем, можно ли полностью вписать символ в текущую позицию на
        ; экране, если нет - на выход
        mov di,[vx_cursor_x]            ; позиция курсора по X
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        test ax,ax
        jz short PrntChrJExit           ; нулевая ширина, ошибка
        add ax,di                       ; первый пиксель справа после символа
        cmp ax,GFX_SCR_WIDTH            ; не выйдем ли за экран
        ja short PrntChrJExit
        mov dx,[vx_cursor_y]            ; позиция курсора по Y
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; реальная высота с учетом масштаба
        test ax,ax
        jz short PrntChrJExit           ; нулевая высота, ошибка
        add ax,dx                       ; первый пиксель снизу после символа
        cmp ax,GFX_SCR_HEIGHT           ; не выйдем ли за экран
        ja short PrntChrJExit
        ; считаем адрес верхнего левого угла символа в видеопамяти:
        ; DI = Y * GFX_BYTES_PER_LINE + (X >> 2) + active_page
        mov ax,dx                       ; Y курсора
        mov dx,GFX_BYTES_PER_LINE
        mul dx
        shr di,1                        ; X курсора >> 2
        shr di,1
        add di,ax
        add di,[vx_scr_active]          ; начало активной видеостраницы

        ; предрасчет смещения вниз на K строк экрана, где K = масштаб
        mov al,ch                       ; масштаб
        mov dl,GFX_BYTES_PER_LINE
        mul dl
        mov bp,ax                       ; сохраняем в BP для использования
                                        ; в цикле потом

        mov ax,[vx_cursor_x]            ; позиция курсора по X
        mov cl,al
        and cl,00000011b
        mov al,00000001b
        shl al,cl
        mov cl,al                       ; CL = маска битовых планов для
                                        ; первого пикселя строки

        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        cmp ax,100h
        ja short PrntChrJExit           ; реальная ширина больше 256, ошибка
        mov ch,al                       ; CH = ширина симв. с учетом масштаба,
                                        ; 0 = 256

        mov dl,[vx_font_height]         ; DL = высота символа, счетчик цикла

        ; сохраняем и заменяем сегментные регистры, после этого доступ к
        ; глобальным переменным будет невозможен
        push ds
        push es
        mov ax,[vx_font_addr]
        mov ds,ax                       ; DS = сегмент шрифта
        mov ax,GFX_SCR_ADDR
        mov es,ax                       ; ES = видеобуфер

        ; AL - битовый буфер для чтения шрифта
        ; AH - текущее количество битов в нем
        mov ah,0

PrntChr1:
        ; рисуем следующую линию шрифта
        push cx                         ; нач. маска и число пикселей в строке
        push dx                         ; счетчик строк
        push di                         ; позиция в видеобуфере

PrntChr2:
        ; формируем маску битовых планов для очередного блока пикселей
        mov dh,0                        ; DH = маска

PrntChr3:
        test ah,ah                      ; есть ли данные в буфере шрифта?
        jnz short PrntChr4
        lodsb                           ; читаем очередные 8 бит
        mov ah,8                        ; bits = 8
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc dl                          ; DL = счетчик повторов = масштаб
PrntChr4:
        test al,10000000b               ; проверяем очередной бит шрифта
        jz short PrntChr5
        or dh,cl                        ; устанавливаем бит маски
PrntChr5:
        shl cl,1                        ; сдвигаем бит-модификатор маски
        dec dl                          ; счетчик повторов (для масштаба)
        jnz short PrntChr6
        shl al,1                        ; удаляем бит шрифта из буфера
        dec ah                          ; bits--
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc dl                          ; DL = счетчик повторов = масштаб
PrntChr6:
        dec ch                          ; счетчик пикселей в линии
        jz short PrntChr7               ; закончили линию
        cmp cl,00010000b                ; перешли границу блока?
        jnz short PrntChr3

PrntChr7:
        ; рисуем "столбик" из закрашенных пикселей высотой, равной коэфф-у
        ; масштабирования
        test dh,dh                      ; если маска нулевая, рисовать нечего
        jz short PrntChr8
        push ax
        mov cl,dl                       ; сохраняем счетчик повторов
        mov ah,dh                       ; маска битовых планов
        mov al,02h                      ; адрес регистра VGA
        mov dx,VGA_SEQUENCER_ADDR
        out dx,ax                       ; пишем в регистр маски
        mov dl,bh                       ; битовые параметры
        and dl,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc dl                          ; коэфф-т масштабирования
PrntChr9:
        mov es:[di],bl                  ; пишем в видеобуфер
        add di,GFX_BYTES_PER_LINE       ; переходим на линию ниже
        dec dl
        jnz short PrntChr9              ; следующий пиксель в столбике
        sub di,bp                       ; восстанавливаем позицию
        mov dl,cl                       ; восстанавливаем счетчик повторов
        pop ax

PrntChr8:
        ; переходим к следующему блоку в строке
        inc di                          ; следующий байт в буфере
        mov cl,00000001b                ; сбрасываем позицию в маске
        test ch,ch                      ; сколько пикселей осталось в строке
        jnz short PrntChr2

        ; переходим к следующей строке
        pop di                          ; восстанавливаем позицию в буфере
        pop dx
        pop cx

        add di,bp                       ; на Scale строк вниз
        dec dl                          ; счетчик строк
        jnz short PrntChr1

        ; восстанавливаем сегментные регистры (и доступ к переменным)
        pop es
        pop ds

        ; сдвигаем курсор на ширину символа (с учетом масштаба), проверяем,
        ; влезет ли еще один символ на ту же строку; если нет, спускаемся
        ; на следующую
        mov ch,bh                       ; битовые параметры
        and ch,CHAR_SCALE_MASK          ; выделяем масштабирование
        inc ch                          ; коэфф-т масштабирования
        mov dx,[vx_cursor_x]            ; X курсора
        mov al,[vx_font_width]          ; ширина символа
        mul ch                          ; умножаем на масштаб
        add dx,ax                       ; первый пиксель справа после символа
        mov [vx_cursor_x],dx            ; = новая позиция курсора
        add dx,ax                       ; а еще символ влезет?
        cmp dx,GFX_SCR_WIDTH
        jna short PrntChrExit           ; если да, то на выход
        mov dx,[vx_cursor_y]            ; Y курсора
        mov al,[vx_font_height]         ; высота символа
        mul ch                          ; умножаем на масштаб
        add dx,ax
        mov [vx_cursor_y],dx            ; сдвигаем курсор на строчку ниже
        xor ax,ax
        mov [vx_cursor_x],ax            ; и ставим в начало строки

PrntChrExit:
        ; восстанавливаем регистры
        pop bp
        pop di
        pop si
        pop dx
        pop cx
        pop bx
        pop ax
        popf
        ret
